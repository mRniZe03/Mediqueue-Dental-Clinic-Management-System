const mongoose = require("mongoose");
const ClinicEvent = require("../Model/ClinicEventModel");

/**
 * GET /clinicevent
 */
const getAllEvents = async (req, res) => {
  const { from, to, q, type, published, page = 1, limit = 10 } = req.query;

  try {
    const filter = {};
    if (type) filter.eventType = type;
    if (typeof published !== "undefined") filter.isPublished = (published === "true");

    if (from || to) {
      filter.$or = [{
        startDate: { $lte: to ? new Date(to) : new Date("9999-12-31") },
        endDate:   { $gte: from ? new Date(from) : new Date("0001-01-01") }
      }];
    }

    if (q) filter.$text = { $search: q };

    const pageNum = parseInt(page, 10) || 1;
    const limitNum = parseInt(limit, 10) || 10;
    const skip = (pageNum - 1) * limitNum;

    const [items, total] = await Promise.all([
      ClinicEvent.find(filter)
        .sort({ startDate: 1, title: 1 })
        .skip(skip)
        .limit(limitNum)
        .lean(),
      ClinicEvent.countDocuments(filter)
    ]);

    return res.status(200).json({
      items,
      page: pageNum,
      limit: limitNum,
      total,
      pages: Math.ceil(total / limitNum)
    });
  } catch (err) {
    console.error("getAllEvents error:", err);
    return res.status(500).json({ message: "Failed to list clinic events", error: err.message });
  }
};

/**
 * POST /clinicevent
 */
const addEvent = async (req, res) => {
  try {
    const { title, description, startDate, endDate, allDay, eventType, isPublished, imageUrl } = req.body;
    if (!title || !startDate) {
      return res.status(400).json({ message: "title and startDate are required" });
    }

    const s = new Date(startDate);
    const e = endDate ? new Date(endDate) : new Date(startDate);

    const payload = {
      title,
      description,
      startDate: s,
      endDate: e,
      allDay: typeof allDay === "boolean" ? allDay : true,
      eventType: eventType || "Other",
      isPublished: !!isPublished,
      imageUrl: imageUrl || null
      // eventCode auto-generated by model
    };

    if (mongoose.isValidObjectId(req.user?.id)) {
      payload.createdBy = req.user.id;
    }

    const event = await ClinicEvent.create(payload);
    return res.status(201).json({ event });
  } catch (err) {
    console.error("addEvent error:", err);
    return res.status(500).json({ message: "Failed to create event", error: err.message });
  }
};

/**
 * GET /clinicevent/:id
 */
const getById = async (req, res) => {
  try {
    const event = await ClinicEvent.findById(req.params.id).lean();
    if (!event) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ event });
  } catch (err) {
    console.error("getById error:", err);
    return res.status(500).json({ message: "Failed to get event", error: err.message });
  }
};

/**
 * GET /clinicevent/code/:eventCode
 */
const getByCode = async (req, res) => {
  try {
    const event = await ClinicEvent.findOne({ eventCode: req.params.eventCode }).lean();
    if (!event) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ event });
  } catch (err) {
    console.error("getByCode error:", err);
    return res.status(500).json({ message: "Failed to get event by code", error: err.message });
  }
};

/**
 * PUT /clinicevent/:id
 */
const updateEvent = async (req, res) => {
  try {
    const allowed = [
      "title",
      "description",
      "startDate",
      "endDate",
      "allDay",
      "eventType",
      "isPublished",
      "imageUrl"
    ];

    const updates = {};
    for (const k of allowed) {
      if (k in req.body) updates[k] = req.body[k];
    }

    if (updates.startDate) updates.startDate = new Date(updates.startDate);
    if (updates.endDate)   updates.endDate   = new Date(updates.endDate);

    if (mongoose.isValidObjectId(req.user?.id)) {
      updates.updatedBy = req.user.id;
    }

    const event = await ClinicEvent.findByIdAndUpdate(
      req.params.id,
      updates,
      { new: true, runValidators: true }
    );

    if (!event) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ event });
  } catch (err) {
    console.error("updateEvent error:", err);
    return res.status(500).json({ message: "Failed to update event", error: err.message });
  }
};

/**
 * DELETE /clinicevent/:id
 */
const deleteEvent = async (req, res) => {
  try {
    const deleted = await ClinicEvent.findByIdAndDelete(req.params.id);
    if (!deleted) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ message: "Event deleted", id: req.params.id });
  } catch (err) {
    console.error("deleteEvent error:", err);
    return res.status(500).json({ message: "Failed to delete event", error: err.message });
  }
};

/**
 * PATCH /clinicevent/:id/publish
 */
const publishEvent = async (req, res) => {
  try {
    const updates = { isPublished: true };
    if (mongoose.isValidObjectId(req.user?.id)) updates.updatedBy = req.user.id;

    const event = await ClinicEvent.findByIdAndUpdate(req.params.id, updates, { new: true });
    if (!event) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ event });
  } catch (err) {
    console.error("publishEvent error:", err);
    return res.status(500).json({ message: "Failed to publish event", error: err.message });
  }
};

/**
 * PATCH /clinicevent/:id/unpublish
 */
const unpublishEvent = async (req, res) => {
  try {
    const updates = { isPublished: false };
    if (mongoose.isValidObjectId(req.user?.id)) updates.updatedBy = req.user.id;

    const event = await ClinicEvent.findByIdAndUpdate(req.params.id, updates, { new: true });
    if (!event) return res.status(404).json({ message: "Event not found" });
    return res.status(200).json({ event });
  } catch (err) {
    console.error("unpublishEvent error:", err);
    return res.status(500).json({ message: "Failed to unpublish event", error: err.message });
  }
};

// Exports
exports.getAllEvents   = getAllEvents;
exports.addEvent       = addEvent;
exports.getById        = getById;
exports.getByCode      = getByCode;   
exports.updateEvent    = updateEvent;
exports.deleteEvent    = deleteEvent;
exports.publishEvent   = publishEvent;
exports.unpublishEvent = unpublishEvent;
